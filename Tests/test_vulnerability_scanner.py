import unittest
from unittest.mock import patch, MagicMock, AsyncMock
from typer.testing import CliRunner
import typer
from chimera_intel.core.vulnerability_scanner import (
    run_port_scan,
    get_vulnerabilities_vulners,
    vulnerability_app,
)
from chimera_intel.core.schemas import HostScanResult, CVE
import nmap

runner = CliRunner()


class TestVulnersIntegration(unittest.TestCase):
    """Test cases specifically for the Vulners API integration."""

    @patch("chimera_intel.core.vulnerability_scanner.sync_client.post")
    def test_get_vulnerabilities_success(self, mock_post: MagicMock):
        """
        Tests a successful CVE lookup from the Vulners API.
        """
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "result": "ok",
            "data": {
                "search": [
                    {
                        "id": "CVE-2021-1234",
                        "cvss": {"score": 9.8},
                        "title": "A critical vulnerability in Nginx",
                    }
                ]
            },
        }
        mock_post.return_value = mock_response
        vulnerabilities = get_vulnerabilities_vulners("nginx", "1.21", "fake_key")
        self.assertEqual(len(vulnerabilities), 1)
        self.assertIsInstance(vulnerabilities[0], CVE)
        self.assertEqual(vulnerabilities[0].id, "CVE-2021-1234")
        self.assertEqual(vulnerabilities[0].cvss_score, 9.8)

    @patch("chimera_intel.core.vulnerability_scanner.sync_client.post")
    def test_get_vulnerabilities_api_error(self, mock_post: MagicMock):
        """
        Tests the CVE lookup when the Vulners API returns an error.
        """
        mock_post.side_effect = Exception("API connection failed")
        vulnerabilities = get_vulnerabilities_vulners("nginx", "1.21", "fake_key")
        self.assertEqual(len(vulnerabilities), 0)

    @patch("chimera_intel.core.vulnerability_scanner.sync_client.post")
    def test_get_vulnerabilities_no_results(self, mock_post: MagicMock):
        """
        Tests the Vulners API response when no CVEs are found for a product.
        """
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "result": "ok",
            "data": {"search": []},
        }
        mock_post.return_value = mock_response
        vulnerabilities = get_vulnerabilities_vulners("some-product", "1.0", "fake_key")
        self.assertEqual(len(vulnerabilities), 0)


class TestVulnerabilityScanner(unittest.TestCase):
    """Test cases for the main vulnerability scanner module."""

    @patch("chimera_intel.core.vulnerability_scanner.get_vulnerabilities_vulners")
    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_success_with_cve(
        self, mock_port_scanner: MagicMock, mock_get_vulns: MagicMock
    ):
        """
        Tests a successful port scan that also finds and attaches CVEs.
        """
        mock_get_vulns.return_value = [
            CVE(id="CVE-2021-1234", cvss=9.8, title="Fake Nginx CVE")
        ]
        mock_nm = MagicMock()
        mock_port_scanner.return_value = mock_nm
        mock_nm.all_hosts.return_value = ["127.0.0.1"]
        mock_host = MagicMock()
        mock_nm.__getitem__.return_value = mock_host
        mock_host.state.return_value = "up"
        mock_host.all_protocols.return_value = ["tcp"]
        mock_tcp_protocol = MagicMock()
        mock_tcp_protocol.keys.return_value = [80, 443]
        mock_tcp_protocol.__getitem__.side_effect = lambda port: {
            80: {
                "state": "open",
                "name": "http",
                "product": "nginx",
                "version": "1.21",
            },
            443: {"state": "open", "name": "https", "product": None, "version": None},
        }[port]
        mock_host.__getitem__.return_value = mock_tcp_protocol
        result = run_port_scan("127.0.0.1", vulners_api_key="fake_key")
        self.assertEqual(result.state, "up")
        self.assertEqual(len(result.open_ports), 2)
        nginx_port = result.open_ports[0]
        self.assertEqual(nginx_port.product, "nginx")
        mock_get_vulns.assert_called_once_with("nginx", "1.21", "fake_key")
        self.assertEqual(len(nginx_port.vulnerabilities), 1)
        self.assertEqual(nginx_port.vulnerabilities[0].id, "CVE-2021-1234")
        https_port = result.open_ports[1]
        self.assertEqual(len(https_port.vulnerabilities), 0)
        self.assertIsNone(result.error)

    @patch("chimera_intel.core.vulnerability_scanner.get_vulnerabilities_vulners")
    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_no_vulners_key(
        self, mock_port_scanner: MagicMock, mock_get_vulns: MagicMock
    ):
        """
        Ensures port scan runs but CVE lookup is skipped if no key is provided.
        """
        mock_nm = MagicMock()
        mock_port_scanner.return_value = mock_nm
        mock_nm.all_hosts.return_value = ["127.0.0.1"]
        mock_host = MagicMock()
        mock_nm.__getitem__.return_value = mock_host
        mock_host.state.return_value = "up"
        mock_host.all_protocols.return_value = ["tcp"]
        mock_tcp_protocol = MagicMock()
        mock_tcp_protocol.keys.return_value = [80]
        mock_tcp_protocol.__getitem__.return_value = {
            "state": "open",
            "name": "http",
            "product": "nginx",
            "version": "1.21",
        }
        mock_host.__getitem__.return_value = mock_tcp_protocol
        result = run_port_scan("127.0.0.1", vulners_api_key=None)
        self.assertEqual(result.state, "up")
        self.assertEqual(len(result.open_ports), 1)
        mock_get_vulns.assert_not_called()
        self.assertEqual(len(result.open_ports[0].vulnerabilities), 0)
        self.assertIsNone(result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_host_down(self, mock_port_scanner: MagicMock):
        """
        Tests the scanner's behavior when the target host is down.
        """
        mock_nm = MagicMock()
        mock_port_scanner.return_value = mock_nm
        mock_nm.all_hosts.return_value = ["127.0.0.1"]
        mock_host = MagicMock()
        mock_nm.__getitem__.return_value = mock_host
        mock_host.state.return_value = "down"
        result = run_port_scan("127.0.0.1", vulners_api_key=None)
        self.assertEqual(result.state, "down")
        self.assertEqual(len(result.open_ports), 0)
        self.assertIsNone(result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_no_open_ports(self, mock_port_scanner: MagicMock):
        """
        Tests the scanner's behavior when a host is up but has no open ports.
        """
        mock_nm = MagicMock()
        mock_port_scanner.return_value = mock_nm
        mock_nm.all_hosts.return_value = ["127.0.0.1"]
        mock_host = MagicMock()
        mock_nm.__getitem__.return_value = mock_host
        mock_host.state.return_value = "up"
        mock_host.all_protocols.return_value = []
        result = run_port_scan("127.0.0.1", vulners_api_key=None)
        self.assertEqual(result.state, "up")
        self.assertEqual(len(result.open_ports), 0)
        self.assertIsNone(result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_nmap_not_found(self, mock_port_scanner: MagicMock):
        """
        Tests the case where nmap is not installed on the system.
        """
        mock_port_scanner.side_effect = nmap.PortScannerError("Nmap not found")
        result = run_port_scan("127.0.0.1", vulners_api_key=None)
        self.assertIn("Nmap not found", result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_unexpected_error(self, mock_port_scanner: MagicMock):
        """
        Tests the case where an unexpected error occurs during scan.
        """
        mock_port_scanner.return_value.scan.side_effect = Exception(
            "Unexpected failure"
        )
        result = run_port_scan("127.0.0.1", vulners_api_key=None)
        self.assertIsNotNone(result.error)
        self.assertIn("Unexpected failure", result.error)

    @patch("chimera_intel.core.vulnerability_scanner.run_vulnerability_scan")
    def test_run_vulnerability_scan_command_logic(
        self,
        mock_run_vuln_scan: MagicMock,
    ):
        """
        Tests the main logic of the vulnerability scan command function.
        """
        mock_run_vuln_scan.return_value = MagicMock()
        with (
            patch("chimera_intel.core.vulnerability_scanner.save_or_print_results"),
            patch("chimera_intel.core.vulnerability_scanner.save_scan_to_db"),
            patch(
                "chimera_intel.core.vulnerability_scanner.resolve_target"
            ) as mock_resolve,
        ):
            mock_resolve.return_value = "example.com"
            from chimera_intel.core.vulnerability_scanner import (
                run_vulnerability_scan_command,
            )

            run_vulnerability_scan_command(domain="example.com", output_file=None)
        mock_resolve.assert_called_with("example.com", required_assets=["domain"])
        mock_run_vuln_scan.assert_called_with("example.com")

    @patch(
        "chimera_intel.core.vulnerability_scanner.gather_footprint_data",
        new_callable=AsyncMock,
    )
    def test_run_vulnerability_scan_footprint_fails(
        self, mock_gather_footprint: AsyncMock
    ):
        """
        Tests resilience when the initial footprint discovery fails.
        """
        mock_gather_footprint.side_effect = Exception("Footprint API is down")
        with patch(
            "chimera_intel.core.vulnerability_scanner.run_port_scan"
        ) as mock_run_port_scan:
            mock_run_port_scan.return_value = HostScanResult(
                host="example.com", state="up", open_ports=[]
            )
            from chimera_intel.core.vulnerability_scanner import run_vulnerability_scan

            run_vulnerability_scan(domain="example.com")
            mock_run_port_scan.assert_called_with("example.com", unittest.mock.ANY)

    def test_cli_vuln_run_invalid_domain(self):
        """
        Tests the 'defensive vuln run' command with an invalid domain.
        """
        result = runner.invoke(vulnerability_app, ["invalid-domain"])
        self.assertEqual(result.exit_code, 1)
        self.assertIn("is not a valid domain format", result.stdout)

    @patch("chimera_intel.core.vulnerability_scanner.run_vulnerability_scan")
    @patch("chimera_intel.core.vulnerability_scanner.resolve_target")
    def test_cli_vuln_run_with_active_project(
        self, mock_resolve_target, mock_run_vuln_scan
    ):
        """Tests the CLI command using an active project's context."""

        def resolve_target_side_effect(domain, required_assets):
            from chimera_intel.core.utils import console

            console.print(
                "[bold cyan]Using domain 'project-vuln.com' from active project 'project-name'.[/bold cyan]"
            )
            return "project-vuln.com"

        mock_resolve_target.side_effect = resolve_target_side_effect
        mock_run_vuln_scan.return_value = MagicMock()
        with (
            patch("chimera_intel.core.vulnerability_scanner.save_or_print_results"),
            patch("chimera_intel.core.vulnerability_scanner.save_scan_to_db"),
        ):
            result = runner.invoke(vulnerability_app, [])
        self.assertEqual(result.exit_code, 0)
        self.assertIn(
            "Using domain 'project-vuln.com' from active project", result.stdout
        )
        mock_run_vuln_scan.assert_called_with("project-vuln.com")

    @patch("chimera_intel.core.vulnerability_scanner.resolve_target")
    def test_cli_vuln_run_no_domain_no_project(self, mock_resolve_target):
        """Tests CLI failure when no domain is given and no project is active."""
        mock_resolve_target.side_effect = typer.Exit(code=1)
        result = runner.invoke(vulnerability_app, [])
        self.assertEqual(result.exit_code, 1)


if __name__ == "__main__":
    unittest.main()
