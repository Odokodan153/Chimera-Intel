import unittest
from unittest.mock import patch, MagicMock, AsyncMock
from chimera_intel.core.vulnerability_scanner import (
    run_port_scan,
    run_vulnerability_scan,
    get_vulnerabilities_vulners,  # Import the new function
)
from chimera_intel.core.schemas import (
    FootprintResult,
    FootprintData,
    SubdomainReport,
    ScoredResult,
    HostScanResult,
    CVE,  # Import the CVE model
)
import nmap


class TestVulnersIntegration(unittest.TestCase):
    """Test cases specifically for the Vulners API integration."""

    @patch("chimera_intel.core.vulnerability_scanner.sync_client.post")
    def test_get_vulnerabilities_success(self, mock_post):
        """Tests a successful CVE lookup from the Vulners API."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "result": "ok",
            "data": {
                "search": [
                    {
                        "id": "CVE-2021-1234",
                        "cvss": {"score": 9.8},
                        "title": "A critical vulnerability in Nginx",
                    }
                ]
            },
        }
        mock_post.return_value = mock_response

        vulnerabilities = get_vulnerabilities_vulners("nginx", "1.21", "fake_key")

        self.assertEqual(len(vulnerabilities), 1)
        self.assertIsInstance(vulnerabilities[0], CVE)
        self.assertEqual(vulnerabilities[0].id, "CVE-2021-1234")
        self.assertEqual(vulnerabilities[0].cvss_score, 9.8)

    @patch("chimera_intel.core.vulnerability_scanner.sync_client.post")
    def test_get_vulnerabilities_api_error(self, mock_post):
        """Tests the CVE lookup when the Vulners API returns an error."""
        mock_post.side_effect = Exception("API connection failed")

        vulnerabilities = get_vulnerabilities_vulners("nginx", "1.21", "fake_key")
        self.assertEqual(len(vulnerabilities), 0)


class TestVulnerabilityScanner(unittest.TestCase):
    """Test cases for the main vulnerability scanner module."""

    # --- CHANGE: Updated test to include CVE lookup ---

    @patch("chimera_intel.core.vulnerability_scanner.get_vulnerabilities_vulners")
    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_success_with_cve(self, mock_port_scanner, mock_get_vulns):
        """
        Tests a successful port scan that also finds and attaches CVEs.

        Args:
            mock_port_scanner (MagicMock): A mock for the `nmap.PortScanner` class.
            mock_get_vulns (MagicMock): A mock for the `get_vulnerabilities_vulners` function.
        """
        # Mock the return value for the vulnerability lookup

        mock_get_vulns.return_value = [
            CVE(id="CVE-2021-1234", cvss_score=9.8, title="Fake Nginx CVE")
        ]

        # --- Nmap mocking remains the same ---

        mock_nm = MagicMock()
        mock_port_scanner.return_value = mock_nm
        mock_nm.all_hosts.return_value = ["127.0.0.1"]
        mock_host = MagicMock()
        mock_nm.__getitem__.return_value = mock_host
        mock_host.state.return_value = "up"
        mock_host.all_protocols.return_value = ["tcp"]
        mock_tcp_protocol = MagicMock()
        mock_tcp_protocol.keys.return_value = [80, 443]
        mock_tcp_protocol.__getitem__.side_effect = lambda port: {
            80: {
                "state": "open",
                "name": "http",
                "product": "nginx",
                "version": "1.21",
            },
            443: {"state": "open", "name": "https", "product": None, "version": None},
        }[port]
        mock_host.__getitem__.return_value = mock_tcp_protocol

        # Run the scan with a fake API key

        result = run_port_scan("127.0.0.1", vulners_api_key="fake_key")

        self.assertEqual(result.state, "up")
        self.assertEqual(len(result.open_ports), 2)

        # --- VERIFICATION: Check that CVEs were found and attached ---

        nginx_port = result.open_ports[0]
        self.assertEqual(nginx_port.product, "nginx")
        # Ensure the mock was called for the nginx service

        mock_get_vulns.assert_called_once_with("nginx", "1.21", "fake_key")
        # Check that the CVE data is present

        self.assertEqual(len(nginx_port.vulnerabilities), 1)
        self.assertEqual(nginx_port.vulnerabilities[0].id, "CVE-2021-1234")

        # Check that the other port has no vulnerabilities

        https_port = result.open_ports[1]
        self.assertEqual(len(https_port.vulnerabilities), 0)
        self.assertIsNone(result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_nmap_not_found(self, mock_port_scanner: MagicMock):
        """
        Tests the case where nmap is not installed on the system.
        """
        mock_port_scanner.side_effect = nmap.PortScannerError("Nmap not found")
        result = run_port_scan("127.0.0.1", vulners_api_key=None)
        self.assertIn("Nmap not found", result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_unexpected_error(self, mock_port_scanner: MagicMock):
        """
        Tests the case where an unexpected error occurs during scan.
        """
        mock_port_scanner.return_value.scan.side_effect = Exception(
            "Unexpected failure"
        )
        result = run_port_scan("127.0.0.1", vulners_api_key=None)
        self.assertIsNotNone(result.error)
        self.assertIn("Unexpected failure", result.error)

    @patch(
        "chimera_intel.core.vulnerability_scanner.gather_footprint_data",
        new_callable=AsyncMock,
    )
    @patch("chimera_intel.core.vulnerability_scanner.run_port_scan")
    @patch("chimera_intel.core.vulnerability_scanner.save_or_print_results")
    @patch("chimera_intel.core.vulnerability_scanner.save_scan_to_db")
    def test_run_vulnerability_scan_command(
        self,
        mock_save_db: MagicMock,
        mock_save_print: MagicMock,
        mock_run_port_scan: MagicMock,
        mock_gather_footprint: AsyncMock,
    ):
        """
        Tests the main vulnerability scan command function.
        """
        mock_footprint_result = FootprintResult(
            domain="example.com",
            footprint=FootprintData(
                whois_info={},
                dns_records={"A": ["1.1.1.1"]},
                subdomains=SubdomainReport(
                    total_unique=1,
                    results=[
                        ScoredResult(
                            domain="sub.example.com",
                            confidence="HIGH",
                            sources=["test"],
                        )
                    ],
                ),
            ),
        )
        mock_gather_footprint.return_value = mock_footprint_result
        mock_run_port_scan.return_value = HostScanResult(
            host="mocked_host", state="up", open_ports=[]
        )

        run_vulnerability_scan("example.com")

        self.assertGreaterEqual(
            mock_run_port_scan.call_count, 3
        )  # domain, ip, subdomain
        mock_save_print.assert_called_once()
        mock_save_db.assert_called_once()


if __name__ == "__main__":
    unittest.main()
