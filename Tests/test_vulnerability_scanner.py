import unittest
from unittest.mock import patch, MagicMock, AsyncMock
from chimera_intel.core.vulnerability_scanner import (
    run_port_scan,
    run_vulnerability_scan,
)
from chimera_intel.core.schemas import (
    FootprintResult,
    FootprintData,
    SubdomainReport,
    ScoredResult,
    HostScanResult,
)
import nmap


class TestVulnerabilityScanner(unittest.TestCase):
    """Test cases for the vulnerability scanner module."""

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_success(self, mock_port_scanner: MagicMock):
        """
        Tests a successful port scan with open ports.

        Args:
            mock_port_scanner (MagicMock): A mock for the `nmap.PortScanner` class.
        """
        # Create a mock for the main nmap object

        mock_nm = MagicMock()
        mock_port_scanner.return_value = mock_nm
        mock_nm.all_hosts.return_value = ["127.0.0.1"]

        # Create a specific mock for the host object that nmap returns

        mock_host = MagicMock()
        # Configure what happens when you access nm['127.0.0.1']

        mock_nm.__getitem__.return_value = mock_host

        # Configure the methods and dictionary access for the host mock

        mock_host.state.return_value = "up"
        mock_host.all_protocols.return_value = ["tcp"]

        # This is the key part: the protocol object itself needs to be a mock
        # that also behaves like a dictionary.

        mock_tcp_protocol = MagicMock()
        mock_tcp_protocol.keys.return_value = [80, 443]
        mock_tcp_protocol.__getitem__.side_effect = lambda port: {
            80: {
                "state": "open",
                "name": "http",
                "product": "nginx",
                "version": "1.21",
            },
            443: {"state": "open", "name": "https", "product": None, "version": None},
        }[port]

        # Assign the protocol mock to the host mock

        mock_host.__getitem__.return_value = mock_tcp_protocol

        result = run_port_scan("127.0.0.1")

        self.assertEqual(result.state, "up")
        self.assertEqual(len(result.open_ports), 2)
        self.assertEqual(result.open_ports[0].product, "nginx")
        self.assertIsNone(result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_nmap_not_found(self, mock_port_scanner: MagicMock):
        """
        Tests the case where nmap is not installed on the system.

        Args:
            mock_port_scanner (MagicMock): A mock for the `nmap.PortScanner` class.
        """
        mock_port_scanner.side_effect = nmap.PortScannerError("Nmap not found")

        result = run_port_scan("127.0.0.1")
        self.assertIn("Nmap not found", result.error)

    @patch("chimera_intel.core.vulnerability_scanner.nmap.PortScanner")
    def test_run_port_scan_unexpected_error(self, mock_port_scanner: MagicMock):
        """
        Tests the case where an unexpected error occurs during scan.

        Args:
            mock_port_scanner (MagicMock): A mock for the `nmap.PortScanner` class.
        """
        mock_port_scanner.return_value.scan.side_effect = Exception(
            "Unexpected failure"
        )

        result = run_port_scan("127.0.0.1")
        self.assertIsNotNone(result.error)
        self.assertIn("Unexpected failure", result.error)

    @patch(
        "chimera_intel.core.vulnerability_scanner.gather_footprint_data",
        new_callable=AsyncMock,
    )
    @patch("chimera_intel.core.vulnerability_scanner.run_port_scan")
    @patch("chimera_intel.core.vulnerability_scanner.save_or_print_results")
    @patch("chimera_intel.core.vulnerability_scanner.save_scan_to_db")
    def test_run_vulnerability_scan_command(
        self,
        mock_save_db: MagicMock,
        mock_save_print: MagicMock,
        mock_run_port_scan: MagicMock,
        mock_gather_footprint: AsyncMock,
    ):
        """
        Tests the main vulnerability scan command function.

        Args:
            mock_save_db (MagicMock): A mock for `save_scan_to_db`.
            mock_save_print (MagicMock): A mock for `save_or_print_results`.
            mock_run_port_scan (MagicMock): A mock for `run_port_scan`.
            mock_gather_footprint (AsyncMock): A mock for `gather_footprint_data`.
        """
        mock_footprint_result = FootprintResult(
            domain="example.com",
            footprint=FootprintData(
                whois_info={},
                dns_records={"A": ["1.1.1.1"]},
                subdomains=SubdomainReport(
                    total_unique=1,
                    results=[
                        ScoredResult(
                            domain="sub.example.com",
                            confidence="HIGH",
                            sources=["test"],
                        )
                    ],
                ),
            ),
        )
        mock_gather_footprint.return_value = mock_footprint_result
        mock_run_port_scan.return_value = HostScanResult(
            host="mocked_host", state="up", open_ports=[]
        )

        # Run the command

        run_vulnerability_scan("example.com")

        # Verify that port scan was called for all discovered assets

        self.assertGreaterEqual(
            mock_run_port_scan.call_count, 3
        )  # domain, ip, subdomain
        mock_save_print.assert_called_once()
        mock_save_db.assert_called_once()


if __name__ == "__main__":
    unittest.main()
