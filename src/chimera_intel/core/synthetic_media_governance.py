"""
Synthetic Media Governance Module.

Implements ethical guardrails for synthetic media generation, including
visible watermarking, artifact detection, and an abuse-reporting mechanism.
(Implements requirements from Point 7).

NOTE: This module requires 'pillow' and 'numpy'.
pip install pillow numpy
"""

import logging
import io
import uuid
from datetime import datetime, timezone
from typing import Optional, Dict, Any
# Re-using PIL from forensic_vault.py's dependencies
try:
    from PIL import Image, ImageDraw, ImageFont, ImageFilter
except ImportError:
    logging.critical("Pillow library (PIL) not found. Watermarking/Detection will be non-functional.")
    Image, ImageDraw, ImageFont, ImageFilter = None, None, None, None

# Add numpy for statistical analysis
try:
    import numpy as np
except ImportError:
    logging.critical("Numpy library not found. Statistical detection will be non-functional.")
    np = None

# Re-using DB and utility concepts from media_governance.py
from .schemas import SyntheticAbuseRecord
from .local_db_service import save_scan_to_db, get_scan_from_db
from .utils import console

logger = logging.getLogger(__name__)

# --- Watermarking (Req 7.1) ---

WATERMARK_TEXT = "SYNTHETIC CONTENT - GENERATED BY CHIMERA"
WATERMARK_TAG = "chimera_synthetic_v1"
WATERMARK_FONT_SIZE = 40
WATERMARK_OPACITY = 90  # Out of 255

def apply_visible_watermark(
    image_content: bytes,
    label: str = WATERMARK_TEXT
) -> bytes:
    """
    Applies a visible, semi-transparent watermark to an image.
    
    Args:
        image_content: The raw bytes of the original image.
        label: The text to apply as a watermark.

    Returns:
        The bytes of the watermarked image.
    """
    if not Image:
        logger.warning("Cannot apply watermark: Pillow (PIL) library not available.")
        return image_content

    try:
        with Image.open(io.BytesIO(image_content)) as img:
            if img.mode != 'RGBA':
                img = img.convert('RGBA')

            txt_overlay = Image.new('RGBA', img.size, (255, 255, 255, 0))
            draw = ImageDraw.Draw(txt_overlay)

            try:
                font = ImageFont.truetype("arial.ttf", WATERMARK_FONT_SIZE)
            except IOError:
                logger.debug("Arial font not found, using default font.")
                font = ImageFont.load_default()

            # Position at bottom right
            text_width, text_height = draw.textsize(label, font=font)
            x = img.width - text_width - 10
            y = img.height - text_height - 10
            
            # Draw semi-transparent text
            draw.text((x, y), label, font=font, fill=(255, 255, 255, WATERMARK_OPACITY))

            watermarked_img = Image.alpha_composite(img, txt_overlay)
            
            # Save back to bytes
            img_byte_arr = io.BytesIO()
            # Use PNG to preserve transparency info, or JPEG if original was JPEG
            output_format = 'PNG' if img.format == 'PNG' else 'JPEG'
            if output_format == 'JPEG':
                watermarked_img = watermarked_img.convert('RGB')
                
            watermarked_img.save(img_byte_arr, format=output_format)
            return img_byte_arr.getvalue()
            
    except Exception as e:
        logger.error(f"Failed to apply watermark: {e}", exc_info=True)
        # Return original content on failure
        return image_content

# --- Detection (Req 7.2) ---

def _check_watermark_luminance(img_gray: Any) -> bool:
    """
    Checks for the specific white watermark in the bottom-right corner
    by comparing average luminance against a control patch.
    """
    try:
        # Define watermark patch (bottom-right)
        w, h = img_gray.size
        wm_x_start = max(0, w - 400 - 10)  # Approx. width of our watermark
        wm_y_start = max(0, h - WATERMARK_FONT_SIZE - 10)
        wm_patch = img_gray.crop((wm_x_start, wm_y_start, w - 10, h - 10))
        wm_patch_np = np.array(wm_patch)
        wm_luminance = np.mean(wm_patch_np)
        
        # Define control patch (bottom-left)
        ctrl_x_end = min(w, 400) # Same width
        ctrl_y_start = wm_y_start
        ctrl_patch = img_gray.crop((0, ctrl_y_start, ctrl_x_end, h - 10))
        ctrl_patch_np = np.array(ctrl_patch)
        ctrl_luminance = np.mean(ctrl_patch_np)

        # Heuristic: Watermark is present if the patch is bright (e.g., > 150)
        # AND significantly brighter than the control patch (e.g., 20% brighter).
        # This avoids false positives on images that are just naturally bright
        # in that corner. The opacity (90/255) means it won't be pure white (255).
        
        # The watermark is (255, 255, 255) at ~35% opacity (90/255).
        # (Original_Lum * 0.65) + (255 * 0.35) = (Original_Lum * 0.65) + 89.25
        # It will always be brighter.
        
        # A simpler, more direct check for our specific watermark:
        # Is the luminance in this area unusually high and uniform?
        
        if wm_luminance > (ctrl_luminance + 20) and wm_luminance > 100:
             # If watermark patch is > 20 luminance points brighter than
             # control patch, and is itself reasonably bright.
            logger.debug(f"Watermark check: PASSED (WM Lum: {wm_luminance}, Ctrl Lum: {ctrl_luminance})")
            return True
            
        logger.debug(f"Watermark check: FAILED (WM Lum: {wm_luminance}, Ctrl Lum: {ctrl_luminance})")
        return False

    except Exception as e:
        logger.warning(f"Watermark luminance check failed: {e}")
        return False

def _check_noise_variance(img_gray: Any) -> bool:
    """
    Checks for unnaturally low noise, a common sign of synthetic media.
    Uses a Laplacian filter to isolate high-frequency noise and
    checks its standard deviation.
    """
    try:
        # Apply Laplacian filter to highlight edges/noise
        laplacian_img = img_gray.filter(ImageFilter.LAPLACIAN)
        laplacian_np = np.array(laplacian_img)
        
        # Calculate the standard deviation of the noise
        noise_std_dev = np.std(laplacian_np)
        logger.debug(f"Noise variance check: Std Dev = {noise_std_dev}")

        # Heuristic: Real photos have sensor noise. Very low noise can be
        # a sign of generative models, heavy airbrushing, or blurring.
        # This threshold is empirical and would need tuning.
        LOW_NOISE_THRESHOLD = 3.0
        if noise_std_dev < LOW_NOISE_THRESHOLD:
            return True # Flagged as suspicious (low noise)
            
        return False # Noise level appears normal

    except Exception as e:
        logger.warning(f"Noise variance check failed: {e}")
        return False


def detect_synthetic_artifacts(asset_content: bytes) -> Dict[str, Any]:
    """
    Detects synthetic media artifacts or watermarks using image processing.
    
    This is a "real" (non-ML) implementation that checks for:
    1.  The specific visible watermark applied by this module.
    2.  Unnaturally low noise variance, a common artifact of generative models.

    Returns:
        A dictionary with detection results.
    """
    if not Image or not np:
        logger.error("Cannot detect artifacts: Pillow or Numpy not available.")
        return {"error": "Detection libraries not initialized."}

    logger.info("Running synthetic artifact detection...")
    
    try:
        with Image.open(io.BytesIO(asset_content)) as img:
            img_gray = img.convert('L') # Convert to grayscale for analysis

            # --- 1. Check for our specific watermark ---
            if _check_watermark_luminance(img_gray):
                return {
                    "is_synthetic": True,
                    "confidence": 0.95,
                    "details": "Visible 'SYNTHETIC CONTENT' watermark detected.",
                    "watermark_tag": WATERMARK_TAG,
                    "method": "Luminance Patch Analysis"
                }

            # --- 2. Check for general artifacts (low noise) ---
            if _check_noise_variance(img_gray):
                return {
                    "is_synthetic": True,
                    "confidence": 0.70,
                    "details": "Image exhibits unnaturally low noise variance, consistent with some generative models.",
                    "watermark_tag": None,
                    "method": "Laplacian Noise Variance"
                }

            # --- 3. No artifacts found ---
            return {
                "is_synthetic": False,
                "confidence": 0.90,
                "details": "No specific watermarks or low-noise artifacts detected.",
                "watermark_tag": None,
                "method": "All checks passed"
            }

    except Exception as e:
        logger.error(f"Artifact detection failed: {e}", exc_info=True)
        return {
            "is_synthetic": False,
            "confidence": 0.0,
            "details": f"Detection failed due to processing error: {e}",
            "watermark_tag": None
        }


# --- Abuse & Takedown (Req 7.3) ---

def log_abuse_report(
    generated_asset_id: str,
    reporter: str,
    reason: str
) -> str:
    """
    Logs an abuse or takedown request for a generated asset.
    
    This creates an auditable SyntheticAbuseRecord and saves it to the
    database, similar to how media_governance.py saves consent logs.

    Args:
        generated_asset_id: The ID of the asset being reported.
        reporter: The email or ID of the person reporting.
        reason: The reason for the report.

    Returns:
        The `report_id` of the newly created abuse record.
    """
    logger.info(f"Logging abuse report for asset {generated_asset_id} by {reporter}.")
    
    try:
        abuse_record = SyntheticAbuseRecord(
            generated_asset_id=generated_asset_id,
            reporter=reporter,
            reason=reason
        )
        
        # Save the record to the DB using the same pattern as other modules
        save_scan_to_db(
            target=generated_asset_id,
            module="synthetic_abuse_log", # Special module name
            data=abuse_record.model_dump(),
            scan_id=abuse_record.report_id # Use the record's own ID
        )
        
        logger.info(f"Abuse report {abuse_record.report_id} saved to DB.")
        console.print(f"[bold yellow]Abuse report logged:[/bold yellow] {abuse_record.report_id}")
        return abuse_record.report_id

    except Exception as e:
        logger.error(f"Failed to save abuse report to DB: {e}", exc_info=True)
        raise

def get_abuse_report(report_id: str) -> Optional[SyntheticAbuseRecord]:
    """Retrieves a specific abuse report from the database."""
    try:
        record_data = get_scan_from_db(report_id, module_name="synthetic_abuse_log")
        if not record_data:
            return None
        return SyntheticAbuseRecord(**record_data['data'])
    except Exception as e:
        logger.error(f"Failed to retrieve abuse report {report_id}: {e}")
        return None