import typer
import nmap
import logging
from typing import List, Optional
from .schemas import PortDetail, HostScanResult, VulnerabilityScanResult, CVE
from .footprint import gather_footprint_data
from .utils import save_or_print_results, console, is_valid_domain
from .database import save_scan_to_db
from .config_loader import API_KEYS
from .http_client import sync_client
import asyncio
from .project_manager import resolve_target
from rich.panel import Panel

logger = logging.getLogger(__name__)


def get_vulnerabilities_vulners(product: str, version: str, api_key: str) -> List[CVE]:
    """
    Queries the Vulners API to find CVEs for a specific product and version.

    Args:
        product (str): The name of the software (e.g., 'nginx').
        version (str): The version of the software (e.g., '1.21').
        api_key (str): The Vulners API key.

    Returns:
        List[CVE]: A list of CVEs found for the software.
    """
    if not product or not version:
        return []
    url = "https://vulners.com/api/v3/software/cve/"
    payload = {
        "apiKey": api_key,
        "software": product,
        "version": version,
        "maxVulnerabilities": 10,
    }
    try:
        response = sync_client.post(url, json=payload)
        response.raise_for_status()
        data = response.json()

        if data.get("result") == "ok":
            cve_list = []
            for cve_data in data.get("data", {}).get("search", []):
                cvss_score = cve_data.get("cvss", {}).get("score", 0.0)
                cve_item = {
                    "id": cve_data.get("id"),
                    "cvss": cvss_score,
                    "title": cve_data.get("title"),
                }
                cve_list.append(CVE.model_validate(cve_item))
            return cve_list
        return []
    except Exception as e:
        logger.error("Error querying Vulners for %s %s: %s", product, version, e)
        return []

async def search_vulnerabilities(service: Optional[str]) -> List[CVE]:
    """
    Searches for CVEs by service/product name to be used by the risk assessment module.
    It runs the synchronous Vulners query in a separate thread.
    """
    if not service:
        return []

    vulners_key = API_KEYS.vulners_api_key
    if not vulners_key:
        logger.warning("Vulners API key is not configured for CVE search.")
        return []

    # Run the synchronous function in a thread to avoid blocking the event loop
    # We use an empty version string for a broader search by service name.
    return await asyncio.to_thread(
        get_vulnerabilities_vulners, service, "", vulners_key
    )

def run_port_scan(target: str, vulners_api_key: str | None) -> HostScanResult:
    """
    Performs a port scan on a single target and correlates findings with CVEs.

    Args:
        target (str): The IP address or hostname to scan.
        vulners_api_key (str | None): The Vulners API key, if available.

    Returns:
        HostScanResult: A Pydantic model containing the scan results.
    """
    try:
        nm = nmap.PortScanner()
        nm.scan(target, arguments="-sV -T4")

        open_ports: List[PortDetail] = []
        host_state = "down"

        if target in nm.all_hosts():
            host_state = nm[target].state()
            for proto in nm[target].all_protocols():
                ports = nm[target][proto].keys()
                for port in ports:
                    port_info = nm[target][proto][port]
                    product = port_info.get("product")
                    version = port_info.get("version")

                    vulnerabilities = []
                    if product and version and vulners_api_key:
                        vulnerabilities = get_vulnerabilities_vulners(
                            product, version, vulners_api_key
                        )
                    open_ports.append(
                        PortDetail(
                            port=port,
                            state=port_info["state"],
                            service=port_info["name"],
                            product=product,
                            version=version,
                            vulnerabilities=vulnerabilities,
                        )
                    )
        return HostScanResult(host=target, state=host_state, open_ports=open_ports)
    except nmap.PortScannerError:
        logger.error("Nmap not found. Please install nmap on your system.")
        return HostScanResult(
            host=target, state="error", open_ports=[], error="Nmap not found."
        )
    except Exception as e:
        logger.error(
            "An unexpected error occurred during Nmap scan of '%s': %s", target, e
        )
        return HostScanResult(host=target, state="error", open_ports=[], error=str(e))

async def search_vulnerabilities_by_ip(ip_address: str) -> HostScanResult:
    """
    Performs a port and vulnerability scan on a single IP address asynchronously.

    It wraps the synchronous run_port_scan function using asyncio.to_thread.
    """
    vulners_key = API_KEYS.vulners_api_key
    # Run the synchronous function in a thread to avoid blocking the event loop

    return await asyncio.to_thread(run_port_scan, ip_address, vulners_key)

def run_vulnerability_scan(domain: str) -> VulnerabilityScanResult:
    """
    Core logic for discovering assets and scanning them.
    """
    vulners_key = API_KEYS.vulners_api_key
    hosts_to_scan = {domain}

    try:
        with console.status(
            f"[bold cyan]Discovering assets for {domain}...[/bold cyan]"
        ):
            footprint_results = asyncio.run(gather_footprint_data(domain))
        if footprint_results.footprint.subdomains:
            for sub in footprint_results.footprint.subdomains.results:
                if sub.domain:
                    hosts_to_scan.add(sub.domain)
        if (
            footprint_results.footprint.dns_records
            and footprint_results.footprint.dns_records.get("A")
        ):
            for ip in footprint_results.footprint.dns_records.get("A") or []:
                hosts_to_scan.add(ip)
    except Exception as e:
        logger.error(f"Footprint discovery failed: {e}. Scanning primary domain only.")
    console.print(f"Found {len(hosts_to_scan)} unique hosts to scan.")

    scanned_hosts_results: List[HostScanResult] = []

    status_message = "[bold cyan]Scanning hosts...[/bold cyan]"
    if vulners_key:
        status_message = "[bold cyan]Scanning hosts and correlating CVEs...[/bold cyan]"
    with console.status(status_message) as status:
        for host in sorted(list(hosts_to_scan)):
            status.update(f"  -> Scanning host: [bold]{host}[/bold]")
            scan_result = run_port_scan(host, vulners_key)
            scanned_hosts_results.append(scan_result)
    return VulnerabilityScanResult(
        target_domain=domain, scanned_hosts=scanned_hosts_results
    )


vulnerability_app = typer.Typer()


@vulnerability_app.command("run")
def run_vulnerability_scan_command(
    domain: Optional[str] = typer.Argument(
        None, help="The root domain to scan. Uses active project if not provided."
    ),
    output_file: Optional[str] = typer.Option(
        None, "--output", "-o", help="Save results to a JSON file."
    ),
):
    """
    Discovers assets via footprint and scans them for open ports and known vulnerabilities.
    """
    target_domain = resolve_target(domain, required_assets=["domain"])

    if not is_valid_domain(target_domain):
        logger.warning(
            "Invalid domain format provided to 'vuln' command: %s", target_domain
        )
        console.print(
            Panel(
                f"[bold red]Invalid Input:[/] '{target_domain}' is not a valid domain format.",
                title="Error",
                border_style="red",
            )
        )
        raise typer.Exit(code=1)
    logger.info("Starting vulnerability scan for assets of %s", target_domain)

    final_result = run_vulnerability_scan(target_domain)

    results_dict = final_result.model_dump(exclude_none=True)
    save_or_print_results(results_dict, output_file)
    save_scan_to_db(
        target=target_domain, module="vulnerability_scanner", data=results_dict
    )
    logger.info("Vulnerability scan complete for %s", target_domain)
