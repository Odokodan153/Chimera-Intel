import typer
import nmap
import logging
from typing import List
from .schemas import PortDetail, HostScanResult, VulnerabilityScanResult, CVE
from .footprint import gather_footprint_data
from .utils import save_or_print_results, console
from .database import save_scan_to_db
from .config_loader import API_KEYS
from .http_client import sync_client
import asyncio

logger = logging.getLogger(__name__)


def get_vulnerabilities_vulners(product: str, version: str, api_key: str) -> List[CVE]:
    """
    Queries the Vulners API to find CVEs for a specific product and version.

    Args:
        product (str): The name of the software (e.g., 'nginx').
        version (str): The version of the software (e.g., '1.21').
        api_key (str): The Vulners API key.

    Returns:
        List[CVE]: A list of CVEs found for the software.
    """
    if not product or not version:
        return []
    url = "https://vulners.com/api/v3/software/cve/"
    payload = {
        "apiKey": api_key,
        "software": product,
        "version": version,
        "maxVulnerabilities": 10,
    }
    try:
        response = sync_client.post(url, json=payload)
        response.raise_for_status()
        data = response.json()

        if data.get("result") == "ok":
            cve_list = []
            for cve_data in data.get("data", {}).get("search", []):
                # Vulners provides CVSS score in a list, we take the first one

                cvss_score = cve_data.get("cvss", {}).get("score", 0.0)
                cve_item = {
                    "id": cve_data.get("id"),
                    "cvss": cvss_score,
                    "title": cve_data.get("title"),
                }
                cve_list.append(CVE.model_validate(cve_item))
            return cve_list
        return []
    except Exception as e:
        logger.error("Error querying Vulners for %s %s: %s", product, version, e)
        return []


def run_port_scan(target: str, vulners_api_key: str | None) -> HostScanResult:
    """
    Performs a port scan on a single target and correlates findings with CVEs.

    Args:
        target (str): The IP address or hostname to scan.
        vulners_api_key (str | None): The Vulners API key, if available.

    Returns:
        HostScanResult: A Pydantic model containing the scan results.
    """
    try:
        nm = nmap.PortScanner()
        # '-sV' tries to determine the version of the service running on port

        nm.scan(target, arguments="-sV -T4")

        open_ports: List[PortDetail] = []
        host_state = "down"

        if target in nm.all_hosts():
            host_state = nm[target].state()
            for proto in nm[target].all_protocols():
                ports = nm[target][proto].keys()
                for port in ports:
                    port_info = nm[target][proto][port]
                    product = port_info.get("product")
                    version = port_info.get("version")

                    vulnerabilities = []
                    if product and version and vulners_api_key:
                        vulnerabilities = get_vulnerabilities_vulners(
                            product, version, vulners_api_key
                        )
                    open_ports.append(
                        PortDetail(
                            port=port,
                            state=port_info["state"],
                            service=port_info["name"],
                            product=product,
                            version=version,
                            vulnerabilities=vulnerabilities,
                        )
                    )
        return HostScanResult(host=target, state=host_state, open_ports=open_ports)
    except nmap.PortScannerError:
        logger.error("Nmap not found. Please install nmap on your system.")
        return HostScanResult(
            host=target, state="error", open_ports=[], error="Nmap not found."
        )
    except Exception as e:
        logger.error(
            "An unexpected error occurred during Nmap scan of '%s': %s", target, e
        )
        return HostScanResult(host=target, state="error", open_ports=[], error=str(e))


# --- Typer CLI Application ---


vulnerability_app = typer.Typer()


@vulnerability_app.command("run")
def run_vulnerability_scan(
    domain: str = typer.Argument(..., help="The root domain to scan."),
    output_file: str = typer.Option(
        None, "--output", "-o", help="Save results to a JSON file."
    ),
):
    """
    Discovers assets via footprint and scans them for open ports and known vulnerabilities.

    Args:
        domain (str): The root domain to scan.
        output_file (str): Optional path to save results to a JSON file.
    """
    logger.info("Starting vulnerability scan for assets of %s", domain)
    vulners_key = API_KEYS.vulners_api_key

    # Step 1: Discover assets using the footprint module

    with console.status(f"[bold cyan]Discovering assets for {domain}...[/bold cyan]"):
        footprint_results = asyncio.run(gather_footprint_data(domain))
    hosts_to_scan = {domain}  # Start with the main domain
    if footprint_results.footprint.subdomains:
        for sub in footprint_results.footprint.subdomains.results:
            if sub.domain:
                hosts_to_scan.add(sub.domain)
    if (
        footprint_results.footprint.dns_records
        and footprint_results.footprint.dns_records.get("A")
    ):
        for ip in footprint_results.footprint.dns_records.get("A") or []:
            hosts_to_scan.add(ip)
    console.print(f"Found {len(hosts_to_scan)} unique hosts to scan.")

    # Step 2: Scan each discovered host

    scanned_hosts_results: List[HostScanResult] = []

    status_message = "[bold cyan]Scanning hosts...[/bold cyan]"
    if vulners_key:
        status_message = "[bold cyan]Scanning hosts and correlating CVEs...[/bold cyan]"
    with console.status(status_message) as status:
        for host in sorted(list(hosts_to_scan)):
            status.update(f"  -> Scanning host: [bold]{host}[/bold]")
            scan_result = run_port_scan(host, vulners_key)
            scanned_hosts_results.append(scan_result)
    # Step 3: Aggregate and save results

    final_result = VulnerabilityScanResult(
        target_domain=domain, scanned_hosts=scanned_hosts_results
    )

    results_dict = final_result.model_dump(exclude_none=True)
    save_or_print_results(results_dict, output_file)
    save_scan_to_db(target=domain, module="vulnerability_scanner", data=results_dict)
    logger.info("Vulnerability scan complete for %s", domain)
